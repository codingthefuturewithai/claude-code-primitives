# Plan: Convention Layer Architecture & Onboarding Skills

## Context

The AI-native philosophy framework (already saved at `skills/build-ops/references/ai-native-philosophy.md`) identifies the convention layer as one of three compounding assets. But the framework doesn't address HOW teams create and maintain that convention layer — specifically CLAUDE.md files.

**The problem**: Teams have conventions that span all repos (tech stack, coding standards, branching strategy). Duplicating these into every repo's CLAUDE.md doesn't scale. And for greenfield projects, there's no repo to analyze yet — so where does the starting knowledge come from?

**The solution**: Treat team conventions as documentation — store them in the team's configured doc backend (Confluence, Google Drive, or RAG Memory). Provide a skill that retrieves those conventions and generates a lean convention layer per repo using Claude Code's official file hierarchy: a short root CLAUDE.md + modular `.claude/rules/` files.

---

## Research Findings: Claude Code's Official CLAUDE.md System

### The 6-Level Hierarchy (official docs)

| Level | Location | Scope | Priority |
|-------|----------|-------|----------|
| **Managed policy** | `/Library/Application Support/ClaudeCode/CLAUDE.md` (macOS) | Org-wide, cannot be overridden | Highest |
| **Project** | `./CLAUDE.md` or `./.claude/CLAUDE.md` | Team-shared via git | Overrides user |
| **Project rules** | `./.claude/rules/*.md` | Modular, topic-specific, path-scopable | Same as project |
| **User** | `~/.claude/CLAUDE.md` | Personal across all projects | Lowest explicit |
| **Local** | `./CLAUDE.local.md` | Personal per-project (gitignored) | Overrides project & user |
| **Auto memory** | `~/.claude/projects/<project>/memory/` | Claude's own notes to itself | Separate system |

**Key behaviors**:
- All levels are loaded additively — Claude sees everything, more specific wins on conflict
- Parent directory CLAUDE.md files are loaded recursively up to root
- Child directory CLAUDE.md files load on-demand when Claude reads files in those dirs
- `@import` syntax allows referencing other files (max depth 5, truncated at 2000 lines)

### Official Content Guidance

**CLAUDE.md should be SHORT** — under 300 lines max, ideally ~60. Every line is reprocessed with every message. Bloated files cause Claude to ignore instructions.

**Include**: Build commands Claude can't guess, code style rules that differ from defaults, testing instructions, repo etiquette, architectural decisions, environment quirks, common gotchas.

**Exclude**: Anything Claude can figure out from code, standard language conventions, detailed API docs (link instead), frequently changing info, tutorials, file-by-file descriptions, self-evident practices.

### `.claude/rules/` — The Official Modular System

For teams, the official recommendation is `.claude/rules/*.md` for topic-specific rules:
- Smaller files reduce merge conflicts
- Can be shared across projects via symlinks
- Support path-scoped rules via YAML frontmatter:
  ```yaml
  ---
  paths:
    - "src/api/**/*.ts"
  ---
  # API Development Rules
  ```

### Auto Memory — The Official Self-Authoring Pattern

Claude writes its own persistent notes to `~/.claude/projects/<project>/memory/`. This is separate from CLAUDE.md — human writes CLAUDE.md (instructions TO Claude), Claude writes auto-memory (notes FOR itself). The philosophy framework's "self-authoring" section should reference auto-memory, not CLAUDE.md modification.

### `/init` — Built-in Starter Generation

Claude Code already has `/init` to generate a starter CLAUDE.md by analyzing the codebase. Our skill builds on top of this: convention-awareness + reconciliation + modular rules generation.

---

## The Convention Layer Architecture

### Three Layers (updated with research)

| Layer | Scope | Where It Lives | Who Maintains |
|-------|-------|----------------|---------------|
| **Team Conventions** | All repos, all projects | Configured doc backend (Confluence / Google Drive / RAG Memory) | Team lead / periodic team review |
| **Repo Convention Layer** | Single repository | Lean `CLAUDE.md` + `.claude/rules/*.md` (checked into git) | Generated by skill + developer review + auto-memory over time |
| **Personal Preferences** | Individual developer | `~/.claude/CLAUDE.md` + `CLAUDE.local.md` | Individual developer |

### How They Compose

- **Team conventions** are stored centrally in the doc backend. Updated once, pulled into any repo on demand.
- **Repo convention layer** is generated as multiple files:
  - Root `CLAUDE.md` — lean (~60 lines): project overview, build/test commands, key directories
  - `.claude/rules/coding-standards.md` — resolved coding conventions for this repo
  - `.claude/rules/testing.md` — testing framework, approach, coverage expectations
  - `.claude/rules/git-workflow.md` — branching, commits, PR/MR process
  - `.claude/rules/architecture.md` — patterns, key decisions, constraints
  - (additional rules files as needed)
- **Personal preferences** layer on top via `~/.claude/CLAUDE.md` (global) and `CLAUDE.local.md` (per-project, gitignored).
- When team conventions change, developers re-run the generate skill → rules files update.

### Why This Architecture

- **Aligns with official Claude Code patterns** — uses `.claude/rules/` exactly as Anthropic intended
- **Keeps root CLAUDE.md short** — under the recommended ~60 lines, so instructions aren't lost
- **Modular rules reduce merge conflicts** — each topic is a separate file
- **Rules are path-scopable** — different conventions for different parts of a monorepo
- **No new storage mechanism** — team conventions use existing doc backends
- **Everything is standalone** — checked into git, works without the plugin
- **Centrally maintainable** — one source of truth for team conventions in doc backend

---

## Deliverables

### 1. Update philosophy framework document

**File**: `skills/build-ops/references/ai-native-philosophy.md`

**Changes**:
- Add a new section after "Guiding Principles" called **"The Convention Layer Architecture"** covering the three-layer model, Claude Code's official hierarchy, how they compose, and the two skills
- Update Principle 5 ("The Convention Layer Compounds") to reference `.claude/rules/` and auto-memory correctly
- Fix the "self-authoring pattern" to reference auto-memory (Claude's notes to itself), not CLAUDE.md modification
- Update "Phase 1: BASELINE" prerequisites to include convention setup → CLAUDE.md generation as a step before the daily SDLC rhythm
- Update the "Rethinking DevFlow" proposed commands to reflect the skill names

**Status**: ✅ COMPLETE

### 2. Create skill design reference document

**File**: `skills/build-ops/references/convention-layer-skills.md`

Design specs for both skills with interview flows, output formats, reconciliation process, and all three modes.

**Status**: ✅ COMPLETE

### 3. Ingest into RAG Memory

- Reingest updated philosophy doc into `claude-ecosystem` collection (mode=reingest)
- Ingest new skills design doc into `claude-ecosystem` collection

**Status**: ✅ COMPLETE

---

## Skill Designs

### Skill A: Capture Team Conventions

**Name**: `/devflow:foundation:capture-conventions` (naming TBD)

**Purpose**: Guided interview to capture team-wide conventions, then store the result in the team's configured documentation backend.

**Pattern**: Same as `/devflow-setup` (progressive disclosure, guided interview, human gates). Same as `/knowledge-management` (route output to configured doc backend).

**Interview Flow**:

1. **Team Identity** — team/org name, primary domain (web app, mobile, data/ML, DevOps, etc.)

2. **Tech Stack by Project Type** (only relevant types):
   - Frontend: language, framework, component library, state management, CSS approach
   - Backend: language, framework, ORM/database, API style (REST/GraphQL/gRPC)
   - Data/ML: language, frameworks, notebook vs scripts
   - Mobile: native vs cross-platform, framework

3. **Coding Standards** — style guide, formatter, linter, type strictness

4. **Testing Conventions** — framework per stack, coverage requirements, testing philosophy

5. **Git & Workflow** — branching strategy, branch naming, commit message format, PR/MR requirements

6. **Architecture Preferences** — monorepo vs polyrepo, patterns, error handling, logging

7. **Preferred Libraries** — common cross-cutting concerns per stack

**Output**: Structured document stored via configured doc backend. Human-readable, retrievable by the generate skill.

**Re-runnable**: If conventions exist, load them and let the team update specific sections.

### Skill B: Generate / Maintain Repo Convention Layer

**Name**: `/devflow:foundation:generate-claude-md` (naming TBD)

**Purpose**: Analyze a repo, optionally retrieve team conventions, reconcile deviations with developer input, and generate or update the repo's convention layer (lean CLAUDE.md + `.claude/rules/` files).

**Core design principles**:
- **Team conventions are optional.** The skill works without them.
- **Developer has override authority.** Conventions are defaults, not mandates.
- **Deviation detection is core.** For existing repos, compares actual state against team conventions and surfaces every deviation.
- **Complete resolution.** Every deviation presented and resolved — nothing silently ignored.

**Output structure** (generated files):
```
repo/
├── CLAUDE.md                        # Lean: project overview, build/test commands, key dirs (~60 lines)
└── .claude/
    └── rules/
        ├── coding-standards.md      # Resolved coding conventions
        ├── testing.md               # Testing framework, approach, coverage
        ├── git-workflow.md          # Branching, commits, PR/MR process
        └── architecture.md          # Patterns, key decisions, constraints
```

Path-scoped rules where appropriate (e.g., monorepo with frontend + backend):
```yaml
---
paths:
  - "packages/frontend/**"
---
# Frontend Coding Standards
- Use React 18 with TypeScript strict mode
- Component library: Radix UI + Tailwind CSS
```

**Three modes** (auto-detected):

#### Mode 1: Existing Repo, No Convention Layer

**Step 1 — Gather inputs:**
1. Attempt to retrieve team conventions from configured doc backend
   - If available → load them
   - If not (no backend, no doc, network issue) → proceed without
2. Analyze repo:
   - Package files (package.json, pyproject.toml, Cargo.toml, go.mod) → detect stack
   - Config files (.eslintrc, tsconfig, prettier, .editorconfig) → detect existing conventions
   - CI/CD config (.github/workflows, .gitlab-ci.yml) → extract build/test commands
   - Directory structure → document architecture
   - README → extract project context
   - Existing .cursorrules or AI config → migrate relevant content

**Step 2 — Reconciliation (if team conventions exist):**
3. Compare repo analysis against team conventions
4. Present deviation report:
   - **Aligned**: "Repo uses React + TypeScript — matches team convention"
   - **Deviation**: "Repo uses Tailwind CSS, but team convention specifies styled-components"
   - **Not covered**: "Repo uses GraphQL — team conventions don't specify API style"
5. Developer resolves each:
   - **Keep deviation** → rules reflect repo's actual choice
   - **Align with convention** → rules reflect the convention
   - **Customize** → rules reflect the custom decision with context

**Step 3 — Generate:**
6. Generate lean CLAUDE.md (project overview, build/test commands, key directories)
7. Generate `.claude/rules/` files from resolved decisions (one per topic)
8. Present to developer for review
9. Developer approves → write files → suggest committing

**Without conventions**: Skip Step 2. Generate from repo analysis + developer input.

#### Mode 2: Greenfield Repo (no/minimal code)

1. Attempt to retrieve team conventions (optional)
2. Ask: "What type of project?" (if conventions exist, maps to team stacks)
3. Ask: "PRD or project brief?" (if yes, analyze for context)
4. If conventions → present applicable ones, developer accepts/overrides/customizes each
5. If no conventions → ask about stack, standards, testing, etc. directly
6. Generate lean CLAUDE.md + `.claude/rules/` files from resolved decisions
7. TODO sections in rules files for details that will emerge as the project develops
8. Developer reviews → approves → commits

#### Mode 3: Maintenance (convention layer already exists)

1. Attempt to retrieve team conventions (optional)
2. Read existing CLAUDE.md + `.claude/rules/` files
3. Analyze current repo state
4. Present drift report:
   - **Convention drift**: Team conventions changed since last sync?
   - **Repo drift**: New deps, dirs, architectural changes not reflected?
   - **Stale content**: Sections referencing things that no longer exist?
5. Developer resolves each item
6. Update affected files → developer approves → commit

**Key principles**:
- All generated files are standalone — work for any Claude Code user, no plugin required
- Developer ALWAYS has final say
- Skill is useful even without team conventions — still analyzes repo and generates convention layer
- Builds on `/init` rather than replacing it — adds convention-awareness and reconciliation

---

## How This Fits the Maturity Model

**Baseline prerequisite** (before the daily SDLC rhythm):
1. Team runs `/devflow-setup` → configures backends
2. Team runs **capture-conventions** → guided interview → conventions stored in doc backend
3. Each developer runs **generate-claude-md** in their repo(s) → CLAUDE.md + rules generated
4. Now the team is ready for the Baseline SDLC loop

**Ongoing maintenance**:
- Team conventions change → update central document (re-run capture skill or edit directly)
- Developer re-runs generate-claude-md in maintenance mode → convention layer syncs
- Auto-memory accumulates repo-specific learnings (Claude's own notes — separate from CLAUDE.md)
- Periodic team review of both conventions doc and repo convention layers

---

## Full Rethinking DevFlow Restructure Roadmap

This is the proposed phase-based reorganization of the entire DevFlow plugin. NOT yet implemented — captured here for future reference.

### Current Structure
```
commands/build/     (SDLC workflow)
commands/admin/     (setup)
commands/pm/        (project management)
commands/docs/      (documentation)
commands/rag-memory/ (knowledge base)
commands/devops/    (DevOps)
skills/             (build-ops, knowledge-mgmt, repo-explorer)
hooks/              (approval hooks)
```

### Proposed: Organized by Developer Journey
```
foundation/
  setup/          (backend configuration, MCP setup)
  onboard/        (team onboarding, first-time walkthrough)
  claude-md/      (CLAUDE.md generation, maintenance, team review)
  knowledge/      (RAG memory, documentation management)

baseline/           (Phase 1: the daily SDLC loop)
  fetch/          (fetch issue, analyze feasibility)
  plan/           (explore, plan with clarifying questions)
  implement/      (incremental implementation with gates)
  verify/         (test, security review, validation)
  complete/       (PR/MR creation, issue closure)
  maintain/       (post-merge cleanup, CLAUDE.md updates)

accelerate/         (Phase 2: multiply throughput)
  worktrees/      (setup, management, best practices)
  patterns/       (two-Claude review, advanced prompting)
  parallel/       (subagent strategies, context hygiene)

orchestrate/        (Phase 3: team-scale coordination)
  teams/          (agent team templates and patterns)
  automate/       (headless mode, CI integration)
  evolve/         (self-maintaining conventions, feedback loops)

hooks/              (cross-cutting enforcement)
  approval/       (external system protection)
  quality/        (post-edit linting, test running)
  safety/         (migration protection, production guards)
```

### Full Command Mapping

| Current | Proposed | Notes |
|---------|----------|-------|
| `/devflow:build:fetch-issue` | `/devflow:baseline:fetch-issue` | Phase change only |
| `/devflow:build:plan-work` | `/devflow:baseline:plan-issue` | Renamed for consistency |
| `/devflow:build:implement-plan` | `/devflow:baseline:implement-issue` | Renamed for consistency |
| `/devflow:build:security-review` | `/devflow:baseline:security-review` | Phase change only |
| `/devflow:build:complete-issue` | `/devflow:baseline:complete-issue` | Phase change only |
| `/devflow:build:post-merge` | `/devflow:baseline:post-merge` | Phase change only |
| `/devflow:build:create-issue` | `/devflow:baseline:create-issue` | Phase change only |
| `/devflow-setup` | `/devflow:foundation:setup` | Moved to foundation |
| `/knowledge-management` | `/devflow:foundation:knowledge` | Moved to foundation |
| (new) | `/devflow:foundation:capture-conventions` | Guided interview → team conventions stored in doc backend |
| (new) | `/devflow:foundation:generate-claude-md` | Analyze repo + conventions → lean CLAUDE.md + `.claude/rules/` |
| (new) | `/devflow:accelerate:setup-worktrees` | Worktree setup and management |
| (new) | `/devflow:accelerate:review-plan` | Two-Claude review pattern |
| (new) | `/devflow:orchestrate:spawn-team` | Agent team templates |

### Naming Philosophy

`{phase}:{verb}-{object}` — keep the object in the name so commands remain unambiguous as the plugin grows. All issue-centric commands follow `{verb}-issue`.

---

## Verification Checklist

- [x] Read updated `ai-native-philosophy.md` — confirm three-layer model is articulated, auto-memory referenced correctly, Baseline updated
- [x] Read `convention-layer-skills.md` — confirm both skill designs are detailed enough to implement
- [x] Reingest updated philosophy doc into RAG Memory (`claude-ecosystem`, mode=reingest)
- [x] Ingest new skills design doc into RAG Memory (`claude-ecosystem`)
- [ ] Implement Skill A: capture-conventions
- [ ] Implement Skill B: generate-claude-md
- [ ] Bump plugin version + test
- [ ] Full DevFlow restructure (future — separate effort)
